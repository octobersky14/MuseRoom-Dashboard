import {
  JSONRPCMessageSchema
} from "./chunk-WB3RSDXG.js";
import {
  __commonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// browser-external:node:child_process
var require_node_child_process = __commonJS({
  "browser-external:node:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:child_process" has been externalized for browser compatibility. Cannot access "node:child_process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:process
var require_node_process = __commonJS({
  "browser-external:node:process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:process" has been externalized for browser compatibility. Cannot access "node:process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// mcp-client-typescript/node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
var import_node_child_process = __toESM(require_node_child_process());
var import_node_process = __toESM(require_node_process());

// mcp-client-typescript/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf("\n");
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index);
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + "\n";
}

// mcp-client-typescript/node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
var DEFAULT_INHERITED_ENV_VARS = import_node_process.default.platform === "win32" ? [
  "APPDATA",
  "HOMEDRIVE",
  "HOMEPATH",
  "LOCALAPPDATA",
  "PATH",
  "PROCESSOR_ARCHITECTURE",
  "SYSTEMDRIVE",
  "SYSTEMROOT",
  "TEMP",
  "USERNAME",
  "USERPROFILE"
] : (
  /* list inspired by the default env inheritance of sudo */
  ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
);
function getDefaultEnvironment() {
  const env = {};
  for (const key of DEFAULT_INHERITED_ENV_VARS) {
    const value = import_node_process.default.env[key];
    if (value === void 0) {
      continue;
    }
    if (value.startsWith("()")) {
      continue;
    }
    env[key] = value;
  }
  return env;
}
var StdioClientTransport = class {
  constructor(server) {
    this._abortController = new AbortController();
    this._readBuffer = new ReadBuffer();
    this._serverParams = server;
  }
  /**
   * Starts the server process and prepares to communicate with it.
   */
  async start() {
    if (this._process) {
      throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return new Promise((resolve, reject) => {
      var _a, _b, _c, _d, _e, _f;
      this._process = (0, import_node_child_process.spawn)(this._serverParams.command, (_a = this._serverParams.args) !== null && _a !== void 0 ? _a : [], {
        env: (_b = this._serverParams.env) !== null && _b !== void 0 ? _b : getDefaultEnvironment(),
        stdio: ["pipe", "pipe", (_c = this._serverParams.stderr) !== null && _c !== void 0 ? _c : "inherit"],
        shell: false,
        signal: this._abortController.signal,
        windowsHide: import_node_process.default.platform === "win32" && isElectron(),
        cwd: this._serverParams.cwd
      });
      this._process.on("error", (error) => {
        var _a2, _b2;
        if (error.name === "AbortError") {
          (_a2 = this.onclose) === null || _a2 === void 0 ? void 0 : _a2.call(this);
          return;
        }
        reject(error);
        (_b2 = this.onerror) === null || _b2 === void 0 ? void 0 : _b2.call(this, error);
      });
      this._process.on("spawn", () => {
        resolve();
      });
      this._process.on("close", (_code) => {
        var _a2;
        this._process = void 0;
        (_a2 = this.onclose) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      });
      (_d = this._process.stdin) === null || _d === void 0 ? void 0 : _d.on("error", (error) => {
        var _a2;
        (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
      });
      (_e = this._process.stdout) === null || _e === void 0 ? void 0 : _e.on("data", (chunk) => {
        this._readBuffer.append(chunk);
        this.processReadBuffer();
      });
      (_f = this._process.stdout) === null || _f === void 0 ? void 0 : _f.on("error", (error) => {
        var _a2;
        (_a2 = this.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
      });
    });
  }
  /**
   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
   *
   * This is only available after the process has been started.
   */
  get stderr() {
    var _a, _b;
    return (_b = (_a = this._process) === null || _a === void 0 ? void 0 : _a.stderr) !== null && _b !== void 0 ? _b : null;
  }
  processReadBuffer() {
    var _a, _b;
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);
      } catch (error) {
        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
      }
    }
  }
  async close() {
    this._abortController.abort();
    this._process = void 0;
    this._readBuffer.clear();
  }
  send(message) {
    return new Promise((resolve) => {
      var _a;
      if (!((_a = this._process) === null || _a === void 0 ? void 0 : _a.stdin)) {
        throw new Error("Not connected");
      }
      const json = serializeMessage(message);
      if (this._process.stdin.write(json)) {
        resolve();
      } else {
        this._process.stdin.once("drain", resolve);
      }
    });
  }
};
function isElectron() {
  return "type" in import_node_process.default;
}
export {
  DEFAULT_INHERITED_ENV_VARS,
  StdioClientTransport,
  getDefaultEnvironment
};
//# sourceMappingURL=@modelcontextprotocol_sdk_client_stdio__js.js.map
